# 子集
> [力扣原题](https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个整数数组 `nums` ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 `不能` 包含重复的子集。你可以按 `任意顺序` 返回解集。



示例 1：

> 输入：`nums = [1,2,3]`
输出：`[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]`

示例 2：
> 输入：`nums = [0]`
输出：`[[],[0]]`




```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
    const res = []
    function dfs(idx = -1, arr = []) {

        if(idx > -1) {
            arr.push(nums[idx])
        }

        res.push(arr)

        for(let i = idx + 1; i < nums.length; i++) {
            dfs(i, [...arr])
        }
        
    }
    
    dfs()

    return res
};
```

# 解题思路
> 使用深度遍历，因为需要返回所有子集，则不能重复，所以在深度遍历中，`每一层` 的for循环，都`不循环前面已经遍历过的数`即可，即`for循环中的let i = idx + 1;`
以`nums = [1,2,3]`举例：
1. 开始`dfs()`,`第0层`, 结果为 `[]`
2. `第0层`的`for循环 i = 0`,`dfs(0, [])`,进入`第1层`, 结果为`[1]`
3. `第1层`的`for循环 i = 1`,`dfs(1, [1])`,进入`第2层`, 结果为`[1, 2]`
4. `第2层`的`for循环 i = 2`,结果为`[1, 2, 3]`, 退回`第1层`
5. `第1层 `的`for循环 i = 2`,结果为`[1, 3]`，退回`第0层`
6. `第0层`的`for循环 i = 1`,进入`dfs(1, [])`,进入`第1层`, 结果为`[2]`
7. `第1层`的`for循环 i = 2`,结果为`[2, 3]`, 退回`第0层`
8. `第0层`的`for循环 i = 2`,结果为`[3]`
9. 最终输出结果为：`[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]`
